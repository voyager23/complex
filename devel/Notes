

24/10/15
// make a new signature - hash sub_group and signature
double xyz = p->second.sub_group;
p->second.signature = fasthash64((const void*)&xyz, 1 , p->second.signature);
//===========================================================================

12/10/15 from analyse.cpp
//------------------------------------------------------
// analyse each cTocta in terms of the a0_ring configuration
a0_rings.clear();
for(auto c = vct.begin(); c != vct.end(); ++c) {
	a0_current = { (*c)[0][0],(*c)[1][0],(*c)[2][0],(*c)[3][0], (*c)[0][0],(*c)[1][0],(*c)[2][0] };
	// search a0_rings
	found = false;
	for(auto p = a0_rings.begin(); p != a0_rings.end(); ++p) {
		for(int q = 0; q < 4; ++q) {
			found = ( 
			(*p)[q+0] == a0_current[0] &&
			(*p)[q+1] == a0_current[1] &&
			(*p)[q+2] == a0_current[2] &&
			(*p)[q+3] == a0_current[3] 
			);
			if(found) break;
		}
		if(found) break;
	}
	if(!(found)) a0_rings.push_back(a0_current);
}
// report size() of a0_rings
cout << "a0_rings - found: " << a0_rings.size() << std::endl;
//------------------------------------------------------

// print out the contents of a0_rings
for(auto p = a0_rings.begin(); p != a0_rings.end(); ++p) {
	for(int q = 0; q < 4; ++q) cout << (*p)[q] << "\t";
	cout << std::endl;
}			
12/10/15 done



[mike@fc22 sizes]$ ./a.out 
Integer 4 bytes
Double  8 bytes
size_t  8 bytes


				// print 4 vectors and blank line
				for(auto z = (*a).begin(); z != (*a).end(); ++z) {
					cout << *z;
				}
				cout << std::endl;
				for(auto z = (*b).begin(); z != (*b).end(); ++z) {
					cout << *z;
				}
				cout << std::endl;
				for(auto z = (*c).begin(); z != (*c).end(); ++z) {
					cout << *z;
				}
				cout << std::endl;
				for(auto z = (*d).begin(); z != (*d).end(); ++z) {
					cout << *z;
				}
				cout << std::endl;
				cout << std::endl;
				
				std::array<gPrime,12> sig_array = {(*a)[0],(*a)[1],(*a)[2],(*a)[3],\
				(*b)[1],(*b)[2],(*b)[3],\
				(*c)[1],(*c)[2],(*c)[3],\
				(*d)[2],(*d)[3]};

				std::vector<double> hash_base;
					for( auto x=0; x<4; ++x) {
						hash_base.push_back((*a)[x].real());
						hash_base.push_back((*a)[x].imag());
					}
					for( auto x=1; x<4; ++x) {
						hash_base.push_back((*b)[x].real());
						hash_base.push_back((*b)[x].imag());
						hash_base.push_back((*c)[x].real());
						hash_base.push_back((*c)[x].imag());
					}
					for( auto x=2; x<4; ++x) {
						hash_base.push_back((*d)[x].real());
						hash_base.push_back((*d)[x].imag());
					}	
					std::sort(hash_base.begin(),hash_base.end());
					
					size_t hash = fasthash64((const void*)&hash_base, (12*sizeof(double)), 0x12345678);
					
					for(auto x = hash_base.begin(); x != hash_base.end(); ++x) cout << *x << "\t";
					cout << std::endl;
